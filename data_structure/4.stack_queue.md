# 5. 스택/큐(Stack/Queue)

### 5-1. 스택과 연산

- 스택(Stack) 의 개념 

  - 원소를 도착한 시간의 반대 순서로 저장한 리스트

  - 원소의 추가와 제거가 탑(top) 이라고 불리우는 한 끝에서만 일어나는 리스트

    (A list in which insertions and deletions are made at one end called the top)

  - Last-In First-Out (LIFO 또는 FILO)

- 스택에 원소를 추가하는 연산: Push
- 스택에서 원소를 제거하는 연산: Pop



#### 스택의 자료구조

- Size: 스택에 저장할 수 있는 원소의 수

- List of elements: 원소를 저장하는 리스트

- TOP: top의 위치를 나타내는 값

  ```c++
  class Stack {
      int Size;
      DataType *Items;
      int TOP;
  }
  ```

- 스택의 연산

  - 생성(create Stack) : 지정된 크기의 원소를 저장하는 스택을 할당

    - maxStackSize 개의 원소를 저장하는 공간을 할당

    - TOP을 0으로 초기화

      ```C++
      void Stack::CreateStack ( int maxStackSize )
      {
          Size = maxStackSize;
          tItem = new Datatype[Size];
          TOP = 0; // -1로 초기화 할 수도 있음
      }
      
      void main () {
          Stack myStack.CreateStack(4);
      }
      ```

      

  - 엠티(IsEmpty) : 스택에 원소가 없으면 True를 리턴

    - 스택이 비어있으면(empty), True를 리턴

    - 스택이 비어있음 -> TOP == 0

      ```c++
      int stack::is_Empty() {
          return ( TOP == 0 );
      }
      ```

      

  - 풀(IsFull) : 스택에 더 원소를 넣을 수 없으면 True 를 리턴

    - 스택에 더 이상 원소를 추가할 수 없으면 True를 리턴

    - 더 이상 원소를 추가할 수 없음 -> TOP == maxStackSize

      ```c++
      int Stack::is_Full() {
          return ( TOP == maxStackSize );
      }
      ```

      

  - 추가(Push) : 스택에 새로운 원소를 삽입

    - 스택에 새로운 원소를 삽입하는 연산

    - Push는 오직 TOP에서만 수행됨

    - 추가 후에는 TOP을 증가시킬 것

      ```c++
      void Stack::push( DataType DataItem ) {
          Items[TOP] = DataItem;
          TOP++;
      }
      
      void main() {
          myStack.push("Potato");
      }
      ```

    - 예외적인 경우? Overflow, Full인 스택에 원소를 추가하는 경우

      ```c++
      void Stack::push( DataType DataItem ) {
          if ( isFull() )
              printf("Pushing in Full Stack\n");
          Items[TOP] = DataItem;
          TOP++;
      }
      ```

      

  - 제거(Pop) : 스택에서 원소를 삭제

    - 스택에서 원소 하나를 삭제하고 리턴하는 연산

    - Pop은 TOP에서 가장 가까운 원소를 제거함

    - 제거한 다음 반드시 TOP을 1 감소시킬 것

      ```c++
      Datatype Stack::pop() {
          TOP--;
          return Items[TOP];
      }
      
      main() {
          Data = Stack.pop();
      }
      ```

    - 예외적인 경우? Underflow, Empty인 스택에서 원소를 제거하는 경우

      ```c++
      Datatype Stack::pop() {
          if ( is_Empty() )
              printf("Poping from Empty Stack\n")
          
          TOP--;
          return Items[TOP];
      }
      ```

  - 탑(TOP)

    - TOP에서 가장 가까운 원소를 제거하지 않고 리턴하는 연산